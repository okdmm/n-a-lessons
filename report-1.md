# レポート1

## マシンイプシロンいついて
以下の手順でマシンイプシロンを求めた
```machine-epsiron.c
#include<stdio.h>

int main(){
  double e;
  e = 1.0;

  while( 1.0 + e != 1.0){
    e /= 2.0;
  }
  printf("%g",e*2.0);
}
```
結果
```
2.22045e-16
```
以上を適宜思い出して考察に使う

## 問題1
### (1)
倍精度における最小のnは以下を経て求めた

```1-1.c
#include<stdio.h>
#include<math.h>

int main(){
  int i;
  double a[100];
  double S[100];
  double epsiron = 2.22045e-16;

  /*級数のの定義*/
  a[0] = 0.0;
  a[1] = 1.0;

  S[0] = 0.0;
  S[1] = a[1];

  for(i=2; i< 100; i++){
    a[i] = a[i-1]/(i*i);
    S[i] = S[i-1] + a[i];
    printf("a[%d] = %g\n", i, a[i]);
    printf("S[%d] = %f \n",i,S[i]);
    if ( S[i] == S[i-1]){
      printf("n = %d\n", i);
      printf("S[%d] = %f \nS[%d] = %f \n ",i-1,S[i-1], i, S[i]);
      break;
    }
    /*if (fabs(S[i] - S[i-1]) <= epsiron ){
      printf("n = %d\n", i);
      printf("S[%d] = %f \nS[%d] = %f \n ",i-1,S[i-1], i, S[i]);
      break;
    }*/
  }
 }
```

その結果

```
a[2] = 0.25
S[2] = 1.250000
a[3] = 0.0277778
S[3] = 1.277778
a[4] = 0.00173611
S[4] = 1.279514
a[5] = 6.94444e-05
S[5] = 1.279583
a[6] = 1.92901e-06
S[6] = 1.279585
a[7] = 3.93676e-08
S[7] = 1.279585
a[8] = 6.15119e-10
S[8] = 1.279585
a[9] = 7.59406e-12
S[9] = 1.279585
a[10] = 7.59406e-14
S[10] = 1.279585
a[11] = 6.27608e-16
S[11] = 1.279585
a[12] = 4.35839e-18
S[12] = 1.279585
n = 12
S[11] = 1.279585
S[12] = 1.279585
```
が求まった。

### (2)
(1)の結果を考察する。

### 概要
問題１で定義された正項級数は収束する。そのためある項はマシンイプシロンより小さくなる。
その項を具体的に求めることができた。以下ではその具体的な数値をあげ、仕組みを説明する。

### 考察
#### double型の有効数字は7桁
(1)の結果よりn=6以降のS[n]の値は有効数字７桁の範囲では一緒である。
#### n=12について
(1)よりn=12で値が一致した。
これは

```
a[12] = 4.35839e-18
```

が倍精度のマシンイプシロン

```
2.22045e-16
```

より小さいため倍精度では0扱い,つまりS[12]はS[11]に0を足したものとなる。
そのため値が一緒になった。

この事を踏まえた上で

```
    if ( S[i] == S[i-1]){
      printf("n = %d\n", i);
      printf("S[%d] = %f \nS[%d] = %f \n ",i-1,S[i-1], i, S[i]);
      break;
    }
```

を

```
    if (fabs(S[i] - S[i-1]) <= epsiron ){
      printf("n = %d\n", i);
      printf("S[%d] = %f \nS[%d] = %f \n ",i-1,S[i-1], i, S[i]);
      break;
    }
```

で書き直しても計算結果は一緒である。
実際に

```
a[2] = 0.25
S[2] = 1.250000
a[3] = 0.0277778
S[3] = 1.277778
a[4] = 0.00173611
S[4] = 1.279514
a[5] = 6.94444e-05
S[5] = 1.279583
a[6] = 1.92901e-06
S[6] = 1.279585
a[7] = 3.93676e-08
S[7] = 1.279585
a[8] = 6.15119e-10
S[8] = 1.279585
a[9] = 7.59406e-12
S[9] = 1.279585
a[10] = 7.59406e-14
S[10] = 1.279585
a[11] = 6.27608e-16
S[11] = 1.279585
a[12] = 4.35839e-18
S[12] = 1.279585
n = 12
S[11] = 1.279585
S[12] = 1.279585
```
が得られた。

## 問題2

まずは以下の方法で計算してみる。
```
#include<stdio.h>
#include<math.h>


int main(){
  double x,y;
  double f;
  y = 0.0000001;
  x = 1.0;
  f = 1.0/(sqrt(x+y) - sqrt(x));
  g = (sqrt(x+y) + sqrt(x))/y;
  printf("f = %f\n",f);
  printf("g = %f\n",g);
 }
```
