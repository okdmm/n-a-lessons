# レポート1

## マシンイプシロンいついて
以下の手順でマシンイプシロンを求めた
```machine-epsiron.c
#include<stdio.h>

int main(){
  double e;
  e = 1.0;

  while( 1.0 + e != 1.0){
    e /= 2.0;
  }
  printf("%g",e*2.0);
}
```
結果
```
2.22045e-16
```
以上を適宜思い出して考察に使う

## 問題1
### (1)
倍精度における最小のnは以下を経て求めた

```1-1.c
#include<stdio.h>
#include<math.h>

int main(){
  int i;
  double a[100];
  double S[100];
  double epsiron = 2.22045e-16;

  /*級数のの定義*/
  a[0] = 0.0;
  a[1] = 1.0;

  S[0] = 0.0;
  S[1] = a[1];

  for(i=2; i< 100; i++){
    a[i] = a[i-1]/(i*i);
    S[i] = S[i-1] + a[i];
    printf("a[%d] = %g\n", i, a[i]);
    printf("S[%d] = %f \n",i,S[i]);
    if ( S[i] == S[i-1]){
      printf("n = %d\n", i);
      printf("S[%d] = %f \nS[%d] = %f \n ",i-1,S[i-1], i, S[i]);
      break;
    }
    /*if (fabs(S[i] - S[i-1]) <= epsiron ){
      printf("n = %d\n", i);
      printf("S[%d] = %f \nS[%d] = %f \n ",i-1,S[i-1], i, S[i]);
      break;
    }*/
  }
 }
```

その結果

```
a[2] = 0.25
S[2] = 1.250000
a[3] = 0.0277778
S[3] = 1.277778
a[4] = 0.00173611
S[4] = 1.279514
a[5] = 6.94444e-05
S[5] = 1.279583
a[6] = 1.92901e-06
S[6] = 1.279585
a[7] = 3.93676e-08
S[7] = 1.279585
a[8] = 6.15119e-10
S[8] = 1.279585
a[9] = 7.59406e-12
S[9] = 1.279585
a[10] = 7.59406e-14
S[10] = 1.279585
a[11] = 6.27608e-16
S[11] = 1.279585
a[12] = 4.35839e-18
S[12] = 1.279585
n = 12
S[11] = 1.279585
S[12] = 1.279585
```
が求まった。

### (2)
(1)の結果を考察する。

### 概要
問題１で定義された正項級数は収束する。そのためある部分和の最終項はマシンイプシロンより小さくなる。
その項を具体的に求めることができた。以下ではその具体的な数値をあげ、仕組みを説明する。

### 考察
#### n=12について
(1)よりn=12で値が一致した。
これは

```
a[12] = 4.35839e-18
```

が倍精度のマシンイプシロン

```
2.22045e-16
```

より小さいため倍精度では0扱い,つまりS[12]はS[11]に0を足したものとなる。
そのため値が一緒になった。

この事を踏まえた上で

```
    if ( S[i] == S[i-1]){
      printf("n = %d\n", i);
      printf("S[%d] = %f \nS[%d] = %f \n ",i-1,S[i-1], i, S[i]);
      break;
    }
```

を

```
    if (fabs(S[i] - S[i-1]) <= epsiron ){
      printf("n = %d\n", i);
      printf("S[%d] = %f \nS[%d] = %f \n ",i-1,S[i-1], i, S[i]);
      break;
    }
```

で書き直しても計算結果は一緒である。
実際に

```
a[2] = 0.25
S[2] = 1.250000
a[3] = 0.0277778
S[3] = 1.277778
a[4] = 0.00173611
S[4] = 1.279514
a[5] = 6.94444e-05
S[5] = 1.279583
a[6] = 1.92901e-06
S[6] = 1.279585
a[7] = 3.93676e-08
S[7] = 1.279585
a[8] = 6.15119e-10
S[8] = 1.279585
a[9] = 7.59406e-12
S[9] = 1.279585
a[10] = 7.59406e-14
S[10] = 1.279585
a[11] = 6.27608e-16
S[11] = 1.279585
a[12] = 4.35839e-18
S[12] = 1.279585
n = 12
S[11] = 1.279585
S[12] = 1.279585
```
が得られた。

## 問題2

### 計算結果
発見的なやり方だが、まずは以下の方法で計算してみる。
```
#include<stdio.h>
#include<math.h>

int main(){
  double x,y;
  double f,g;
  y = 0.000001;
  x = 10000000.0;
  f = 1/(sqrt(x+y) - sqrt(x));
  printf("1/f = %.24f\n", sqrt(x+y)-sqrt(x));
  g = (sqrt(x+y) + sqrt(x))/y;
  printf("f = %f\n",f);
  printf("g = %f\n",g);
}
```
すると以下の通り二つの計算式に差がでた。

```
1/f = 0.000000000157797330757603
f = 6337242811.389049
g = 6324555320.336917
```

計算式を有理化した場合としない場合でどれほど差が出るのか以下で考察する。

### 考察
#### 引き算による情報落ちについて

引き算により情報落ちが起こるため

```
  f = 1/(sqrt(x+y) - sqrt(x));
```

の分母の計算で誤差の原因が生じる

#### 有理化による情報落ちを避けられることについて

上と比べ一方

```
  g = (sqrt(x+y) + sqrt(x))/y;
```
と有理化することで引き算を避けているため、丸め込みによる誤差を減らしている。
そのため上と比べ誤差は小さい

