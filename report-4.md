# 演習課題4

## 準備
問題を特にあたり必要な準備をする。スペースを考慮し完全な計算結果とソースコードは載せていない。


### Hilebert行列の定義
問題で使うHilbert行列は以下のプログラムで定義した。

```hilbert.c
  /*Hilbelt行列の定義*/
  for(i = 0; i < N; i++){
    for(j = 0; j < N; j++){
      Hilbelt[i][j] = 1.0/(i + j + 1.0 );
    }
  }
```

簡単のためn=5の時の結果は

```
  /* N = 5 */
  printf(" n = 5\n\n");
  for(i = 0; i < 5; i++){
    for(j = 0; j < 5; j++){
      Hilbelt[i][j] = 1.0/(i + j + 1.0 );
      printf("%lf ", Hilbelt[i][j] );
    }
    printf("\n");
  }
  printf("\n");
```

```
 n = 5

1.000000 0.500000 0.333333 0.250000 0.200000
0.500000 0.333333 0.250000 0.200000 0.166667
0.333333 0.250000 0.200000 0.166667 0.142857
0.250000 0.200000 0.166667 0.142857 0.125000
0.200000 0.166667 0.142857 0.125000 0.111111
```

である。

### Hilbert行列のLU分解(コレスキー分解)
Hilebert行列は実対称行列。よってLU分解より強くコレスキー分解できる。
問題(1)でHilebert行列の逆行列を計算したいのでここでコレスキー分解しておく。
また、Hilebert行列の逆行列は以下のようにコレスキー分解を用いて計算する。

長くなるので便宜上N=5の時のみ

```コレスキー分解.c
  /*Lの計算*/
  for(i = 0; i < 5; i++){
    for( j = 0; j < 5; j++){
      if( j > i ){
        L[i][j] = 0.0;
      }else if( j == i){
          double tmp = 0.0;
        for( int k = 0; k < j; k++){
          tmp += L[j][k]*L[j][k];
        }
        L[j][j] = sqrt(Hilbelt[j][j] - tmp);
      } else {
          double tmp = 0.0;
        for ( int k = 0; k < j; k++){
          tmp += L[i][k]*L[j][k];
        }
        L[i][j] = (Hilbelt[i][j] - tmp)/L[j][j]; 
      }
    } 
  }
  /*Lの表示 */
  printf("Lの表示\n");
  for(i=0; i<5; i++){
    for(j=0; j<5; j++){
      printf("%lf  ", L[i][j]);
    }
    printf("\n");
  }
  /*Uの計算とUの表示*/
  printf("\nUの表示\n");
  for(i=0; i<5; i++){
    for(j=0; j<5; j++){
      U[i][j] = L[j][i];
      printf("%lf", U[i][j]);
    }
    printf("\n");
  }

  /*検算*/
  printf("\n検算\n");
  for(i=0;i<5;i++){
    for(j=0;j<5;j++){
      double tmp = 0.0;
     for(int k=0; k<5; k++){
        tmp += L[i][k]*U[k][j];
     } 
     printf("%lf ", tmp);
    }
    printf("\n");
  }
```

結果は

```
 n = 5

Lの表示
1.000000  0.000000  0.000000  0.000000  0.000000
0.500000  0.288675  0.000000  0.000000  0.000000
0.333333  0.288675  0.074536  0.000000  0.000000
0.250000  0.259808  0.111803  0.018898  0.000000
0.200000  0.230940  0.127775  0.037796  0.004762

Uの表示
1.0000000.5000000.3333330.2500000.200000
0.0000000.2886750.2886750.2598080.230940
0.0000000.0000000.0745360.1118030.127775
0.0000000.0000000.0000000.0188980.037796
0.0000000.0000000.0000000.0000000.004762

検算
1.000000 0.500000 0.333333 0.250000 0.200000
0.500000 0.333333 0.250000 0.200000 0.166667
0.333333 0.250000 0.200000 0.166667 0.142857
0.250000 0.200000 0.166667 0.142857 0.125000
0.200000 0.166667 0.142857 0.125000 0.111111
```

である。

### Hilbert行列の逆行列
これを元にLとUの逆行列を以下で計算する

```inverse.c
  /*Lの逆行列*/
  printf("\nLの逆行列\n");
  for( i = 0;i < 5; i++){
    for( j = 0;j < 5; j++){
      if( i < j ){
        InverseL[i][j] = 0.0;
        printf("%f ", InverseL[i][j]);
      }else if( i == j ){
        InverseL[i][i] = 1.0/L[i][i];
        printf("%f ", InverseL[i][i]);
      }else {
        double tmp = 0.0;
        for(int k = 0; k < i; k++){
          tmp += L[i][k]*InverseL[k][j];
        }
        InverseL[i][j] = - tmp/L[i][i];
        printf("%f ", InverseL[i][j]);
      }
    }
    printf("\n");
  }

  /*L検算*/
  printf("\n検算\n");
  for(i=0;i<5;i++){
    for(j=0;j<5;j++){
      double tmp = 0.0;
     for(int k=0; k<5; k++){
        tmp += L[i][k]*InverseL[k][j];
     } 
     printf("%lf ", tmp);
    }
    printf("\n");
  }

  /*Uの逆行列*/
  printf("\nUの逆行列\n");
  for( i = 0; i < 5; i++ ){
    for(j = 0; j < 5; j++){
      InverseU[i][j] = InverseL[j][i];
      printf("%f ", InverseU[i][j]);
    }
    printf("\n");
  }

  /*U検算*/
  printf("\n検算\n");
  for(i=0;i<5;i++){
    for(j=0;j<5;j++){
      double tmp = 0.0;
     for(int k=0; k<5; k++){
        tmp += InverseU[i][k]*U[k][j];
     } 
     printf("%lf ", tmp);
    }
    printf("\n");
  }
```

実行結果は

```
Lの逆行列
1.000000 0.000000 0.000000 0.000000 0.000000
-1.732051 3.464102 0.000000 0.000000 0.000000
2.236068 -13.416408 13.416408 0.000000 0.000000
-2.645751 31.749016 -79.372539 52.915026 0.000000
3.000000 -60.000000 270.000000 -420.000000 210.000000

検算
1.000000 0.000000 0.000000 0.000000 0.000000
0.000000 1.000000 0.000000 0.000000 0.000000
0.000000 0.000000 1.000000 0.000000 0.000000
-0.000000 0.000000 0.000000 1.000000 0.000000
0.000000 0.000000 0.000000 0.000000 1.000000

Uの逆行列
1.000000 -1.732051 2.236068 -2.645751 3.000000
0.000000 3.464102 -13.416408 31.749016 -60.000000
0.000000 0.000000 13.416408 -79.372539 270.000000
0.000000 0.000000 0.000000 52.915026 -420.000000
0.000000 0.000000 0.000000 0.000000 210.000000

検算
1.000000 0.000000 0.000000 -0.000000 0.000000
0.000000 1.000000 0.000000 0.000000 0.000000
0.000000 0.000000 1.000000 0.000000 0.000000
0.000000 0.000000 0.000000 1.000000 0.000000
0.000000 0.000000 0.000000 0.000000 1.000000
```

$ U^{-1}L^{-1} $ を計算すれば良いので

```
  /*Hilebertの逆行列*/
  printf("\nHilbertの逆行列\n");
  for(i=0;i<5;i++){
    for(j=0;j<5;j++){
        InverseHierbert[i][j]= 0.0;
     for(int k=0; k<5; k++){
        InverseHierbert[i][j]+= InverseU[i][k]*InverseL [k][j];
     } 
     printf("%lf ", InverseHierbert[i][j]);
    }
    printf("\n");
  }

  /*Hilbertの検算*/
  printf("\nHilbertの検算\n");
  for(i=0;i<5;i++){
    for(j=0;j<5;j++){
      double tmp = 0.0;
     for(int k=0; k<5; k++){
        tmp += Hilbelt[i][k]*InverseHierbert[k][j];
     } 
     printf("%lf ", tmp);
    }
    printf("\n");
  }
```

結果は

```
Hilbertの逆行列
25.000000 -300.000000 1050.000000 -1400.000000 630.000000
-300.000000 4800.000000 -18900.000000 26880.000000 -12600.000000
1050.000000 -18900.000000 79380.000000 -117600.000000 56700.000000
-1400.000000 26880.000000 -117600.000000 179199.999999 -88200.000000
630.000000 -12600.000000 56700.000000 -88200.000000 44100.000000

Hilbertの検算
1.000000 -0.000000 -0.000000 0.000000 -0.000000
-0.000000 1.000000 -0.000000 0.000000 -0.000000
-0.000000 0.000000 1.000000 0.000000 0.000000
-0.000000 -0.000000 0.000000 1.000000 0.000000
-0.000000 0.000000 -0.000000 0.000000 1.000000
```

より逆行列が計算できたことが確認できた。
$ n = 10, 15 $の場合は長くなるためレポート末尾に載せた。

## (1)
上の準備の上所望のノルムを計算すると

```
  /*逆行列のノルム*/
  InversRow[0] = 0.0;
  for(i=0;i<N;i++){
    for(j=0;j<N;j++){
      InversRow[i]+= fabsl(InverseHierbert[i][j]);
    }
    printf("%d行の和 = %Lf\n",i, InversRow[i]);
  }
  InversMaxRow = InversRow[0];
  for(i=0;i<N;i++){
    if(InversRow[i] > InversMaxRow)
      InversMaxRow = InversRow[i];
  }

  /*ノルム*/
  Row[0] = 0.0;
  for(i=0;i<N;i++){
    for(j=0;j<N;j++){
      Row[i]+= fabsl(Hilbelt[i][j]);
    }
    printf("%d行の和 = %Lf\n",i, Row[i]);
  }
  MaxRow = Row[0];
  for(i=0;i<N;i++){
    if(Row[i] > MaxRow)
      MaxRow = Row[i];
  }
  printf("\n条件数= %Lf\n", MaxRow*InversMaxRow);
```

| $ n = 5 $ | $ n = 10 $ |$ n = 15 $|
|---|---|---|
|943656.000002|35350806896537.182865|18960736249266216480.000000|


となった。

## (2)
### 近似解を求める
まず、解の要素が全て1となるような右辺項を求める。
つまり、行列と要素がすべて1の縦ベクトルのかけ算をすれば良い。
```
  Row[0] = 0.0;
  for(i=0;i<N;i++){
    for(j=0;j<N;j++){
      Row[i]+= Hilbelt[i][j];
    }
    printf("b[%d] = %Lf\n",i, Row[i]);
  }
```

各nに対する右辺項は

$ n = 5 $
```
b[0] = 2.283333
b[1] = 1.450000
b[2] = 1.092857
b[3] = 0.884524
b[4] = 0.745635
```

$ n = 10 $

```
b[0] = 2.928968
b[1] = 2.019877
b[2] = 1.603211
b[3] = 1.346800
b[4] = 1.168229
b[5] = 1.034896
b[6] = 0.930729
b[7] = 0.846695
b[8] = 0.777251
b[9] = 0.718771
```

$ n = 15 $

``` 
b[0] = 3.318229
b[1] = 2.380729
b[2] = 1.939553
b[3] = 1.661775
b[4] = 1.464406
b[5] = 1.314406
b[6] = 1.195359
b[7] = 1.097956
b[8] = 1.016434
b[9] = 0.946990
b[10] = 0.886990
b[11] = 0.834542
b[12] = 0.788246
b[13] = 0.747037
b[14] = 0.710091
```

となった。
これを踏まえた上でPivot選択付きGaussの消去法によって指定の方程式を解く。
ソースコードは以下。

```gauss.c
#include<stdio.h>
#include<math.h>

int main(){
  int i,j,n,k;
  int pivot;
  int N=10;
  long double Hilbelt[N][N];
  long double A[N][N+1];

  long double MaxRow;
  long double Row[N];
  long double b[N];
  long double c[N];
  long double x[N];


  /*Hilbelt行列の定義*/
  for(i = 0; i < N; i++){
    for(j = 0; j < N; j++){
      Hilbelt[i][j] = 1.0/(i + j + 1.0 );
    }
  }

  /*bの設定*/
  for(i=0;i<N;i++){
    b[i] = 0.0;
    for(j=0;j<N;j++){
      b[i] += Hilbelt[i][j];
    }
    printf("b[%d] = %Lf\n",i, b[i]);
  }

  for(i=0;i<N;i++){
    for(j=0;j<N+1;j++){
      if(j == N){
        A[i][j] = b[i];
      }else{
        A[i][j] = Hilbelt[i][j];
      }
    }
  }

  for(i = 0; i < N; i++){
    for(j = 0; j < N+1; j++){
      printf("%Lf ", A[i][j] );
    }
    printf("\n");
  }

  /*消去法始まり*/
  for(k = 0; k < N-1; k++ ){
    /*pivotの軸探し*/
    pivot = k;
    MaxRow = fabsl(A[k][k]);
    for(i=k+1; i < N; i++){
      if( fabsl(A[i][k]) > MaxRow ){
        MaxRow = fabsl(A[i][k]);
        pivot = i;
      }
    }

    /*もしpivotの必要があるならば交換*/
    if(pivot != k){
      for(i = k; i < N+1; i++){
        long double tmp = A[k][i];
        A[k][i] = A[pivot][i];
        A[pivot][i] = tmp;
      }
    }
    /*pivot完了*/

    /*前進消去して行く*/
    for(i = k+1; i< N; i++){
      long double tmp[N+1];
      tmp[i] = A[i][k]/A[k][k];
      A[i][k] = 0.0;
      for(j = k+1; j < N + 1; j++){
        A[i][j] = A[i][j] - A[k][j]*tmp[i];
      }
    }
  }
  /*掃き出し後の行列を確認*/
  for(i=0; i < N; i++){
    for(j = 0; j < N + 1; j++){
      printf("%Lf  ", A[i][j]);
    }
    printf("\n");
  }

    /*後退代入つまり解の計算*/
  for( i = N-1; i >= 0; i--){
    x[i] = A[i][N];
    for(j = i + 1; j < N; j++){
      x[i]  -=  A[i][j]*x[j];
      A[i][j] = 0.0;
    }
    x[i] /= A[i][i];
    A[i][i] = 1.0;
  }
  for(i = 0; i < N; i++){
    printf("x[d] = %Lf\n",i,x[i]);
  }

}
```

その結果解を$ x $とすると
$ n = 5 $ のとき

```
x[0] = 1.000000
x[1] = 1.000000
x[2] = 1.000000
x[3] = 1.000000
x[4] = 1.000000
```

$ n = 10 $ のとき

```
x[0] = 1.000000
x[1] = 1.000000
x[2] = 1.000000
x[3] = 1.000000
x[4] = 1.000000
x[5] = 1.000000
x[6] = 1.000000
x[7] = 1.000000
x[8] = 1.000000
x[9] = 1.000000
```

$ n = 15 $ のとき

```
x[0] = 1.000000
x[1] = 1.000000
x[2] = 1.000000
x[3] = 1.000001
x[4] = 0.999987
x[5] = 1.000082
x[6] = 0.999683
x[7] = 1.000735
x[8] = 0.999106
x[9] = 1.000031
x[10] = 1.001719
x[11] = 0.997172
x[12] = 1.002265
x[13] = 0.999052
x[14] = 1.000166
```

が求まった。

### 残差ノルムと誤差ノルムを求める。
残差ノルムから求める。

```
  /*近似解との積 */
  /*残差ノルム*/
  for(i=0;i<N;i++){
    Row[i] = 0.0;
    for(j=0;j<N;j++){
      Row[i]+=Hilbelt[i][j]*x[j];
    }
    Row[i] = fabs(b[i] - Row[i]); 
    printf("%d行の和 = %le\n",i, Row[i]);
  }

  MaxRow = Row[0];
  for(i=0;i<N;i++){
    if(Row[i] > MaxRow){
      MaxRow = Row[i];
    }
  }
  printf("\n残差ノルム%le",MaxRow);
```

残差ノルムは

| $ n = 5 $ | $ n = 10 $ |$ n = 15 $|
|---|---|---|
|4.440892e-16 | 2.220446e-16 | 4.440892e-16|

となった。同様に誤差ノルムは

```
  printf("\n誤差ノルム\n");
  for(i=0;i<N;i++){
    Row[i] = fabs(x[i] - 1.0);
    printf("%le\n", Row[i]);
  }

  MaxRow = Row[0];
  for(i=0;i<N;i++){
    if(Row[i] > MaxRow){
      MaxRow= Row[i];
    }
  }

  printf("\n残差ノルム%le\n",MaxRow);
```

から

| $ n = 5 $ | $ n = 10 $ |$ n = 15 $|
|---|---|---|
| 6.168399e-13 | 3.183650e-04 | 6.853930e+00 |

## (3)

右変更の第一成分に誤差を混入させた時の誤差の上限を求める。
まずは誤差を混入する

```
  /*bの設定*/
  for(i=0;i<N;i++){
    b[i] = 0.0;
    for(j=0;j<N;j++){
      b[i] += Hilbelt[i][j];
    }
    printf("b[%d] = %le\n",i, b[i]);
  }

  /*誤差の混入*/
  b[0]*= 1.001; 
```

誤差の上限を計算する. 

| $ n = 5 $ | $ n = 10 $ |$ n = 15 $|
|---|---|---|
| 9.445997e+05 |3.538616e+13 | 1.897970e+19 |

となった。

## (4)

誤差の混入の上連立一次方程式を解くとその解は


$ n = 5 $ 

```
x[0] = 1.057083e+00
x[1] = 3.150000e-01
x[2] = 3.397500e+00
x[3] = -2.196667e+00
x[4] = 2.438500e+00
```

$ n = 10 $ 

```
x[0] = 1.292889e+00
x[1] = -1.349769e+01
x[2] = 2.329592e+02
x[3] = -1.758001e+03
x[4] = 7.388726e+03
x[5] = -1.846815e+04
x[6] = 2.814426e+04
x[7] = -2.562930e+04
x[8] = 1.281608e+04
x[9] = -2.704392e+03
```
$ n = 15 $

```
x[0] = 1.505132e+00
x[1] = -3.728794e+01
x[2] = 9.480781e+02
x[3] = -1.126331e+04
x[4] = 7.576655e+04
x[5] = -3.126182e+05
x[6] = 8.226540e+05
x[7] = -1.395641e+06
x[8] = 1.524011e+06
x[9] = -1.146907e+06
x[10] = 9.070628e+05
x[11] = -1.034266e+06
x[12] = 9.485969e+05
x[13] = -4.749469e+05
x[14] = 9.665332e+04
```

誤差ノルムは

| $ n = 5 $ | $ n = 10 $ |$ n = 15 $|
|---|---|---|
| 3.196667e+00 | 2.814326e+04 | 1.524010e+06 |

## (5)

### 考察
Hilbert行列はnが大きくなるほど条件数が大きくなる。それにつれて方程式の解の誤差も大きくなる。
全体を通して上を踏まえた上で考察する。

### (2), (3)

実際に誤差ノルムと誤差の上限はnが大きくなるほど大きくなっていた。

### (4)

(2)と大きく異なり、nが大きいほど誤差ノルムが大きくなった。このことからも条件数が大きいほど誤差の振れ幅が出やすいということが確認できた。

