# 演習課題4

## 準備
問題を特にあたり必要な準備をする。スペースを考慮し完全な計算結果はレポート末尾に載せた。


### Hilebert行列の定義
問題で使うHilbert行列は以下のプログラムで定義した。
```hilbert.c
  /*Hilbelt行列の定義*/
  for(i = 0; i < N; i++){
    for(j = 0; j < N; j++){
      Hilbelt[i][j] = 1.0/(i + j + 1.0 );
    }
  }
```

簡単のためn=5の時の結果は
```
  /* N = 5 */
  printf(" n = 5\n\n");
  for(i = 0; i < 5; i++){
    for(j = 0; j < 5; j++){
      Hilbelt[i][j] = 1.0/(i + j + 1.0 );
      printf("%lf ", Hilbelt[i][j] );
    }
    printf("\n");
  }
  printf("\n");
```

```
 n = 5

1.000000 0.500000 0.333333 0.250000 0.200000
0.500000 0.333333 0.250000 0.200000 0.166667
0.333333 0.250000 0.200000 0.166667 0.142857
0.250000 0.200000 0.166667 0.142857 0.125000
0.200000 0.166667 0.142857 0.125000 0.111111
```
である。長くなるためそれぞれの計算結果についてはレポート末尾にまとめて付け加えた。

### Hilbert行列のLU分解(コレスキー分解)
Hilebert行列は実対称行列。よってLU分解より強くコレスキー分解できる。
問題(1)でHilebert行列の逆行列を計算したいのでここでコレスキー分解しておく。
また、Hilebert行列の逆行列は以下のようにコレスキー分解を用いて計算する。

長くなるので便宜上N=5の時のみ
```コレスキー分解.c
  /*Lの計算*/
  for(i = 0; i < 5; i++){
    for( j = 0; j < 5; j++){
      if( j > i ){
        L[i][j] = 0.0;
      }else if( j == i){
          double tmp = 0.0;
        for( int k = 0; k < j; k++){
          tmp += L[j][k]*L[j][k];
        }
        L[j][j] = sqrt(Hilbelt[j][j] - tmp);
      } else {
          double tmp = 0.0;
        for ( int k = 0; k < j; k++){
          tmp += L[i][k]*L[j][k];
        }
        L[i][j] = (Hilbelt[i][j] - tmp)/L[j][j]; 
      }
    } 
  }
  /*Lの表示 */
  printf("Lの表示\n");
  for(i=0; i<5; i++){
    for(j=0; j<5; j++){
      printf("%lf  ", L[i][j]);
    }
    printf("\n");
  }
  /*Uの計算とUの表示*/
  printf("\nUの表示\n");
  for(i=0; i<5; i++){
    for(j=0; j<5; j++){
      U[i][j] = L[j][i];
      printf("%lf", U[i][j]);
    }
    printf("\n");
  }

  /*検算*/
  printf("\n検算\n");
  for(i=0;i<5;i++){
    for(j=0;j<5;j++){
      double tmp = 0.0;
     for(int k=0; k<5; k++){
        tmp += L[i][k]*U[k][j];
     } 
     printf("%lf ", tmp);
    }
    printf("\n");
  }
```

結果は

```
 n = 5

Lの表示
1.000000  0.000000  0.000000  0.000000  0.000000
0.500000  0.288675  0.000000  0.000000  0.000000
0.333333  0.288675  0.074536  0.000000  0.000000
0.250000  0.259808  0.111803  0.018898  0.000000
0.200000  0.230940  0.127775  0.037796  0.004762

Uの表示
1.0000000.5000000.3333330.2500000.200000
0.0000000.2886750.2886750.2598080.230940
0.0000000.0000000.0745360.1118030.127775
0.0000000.0000000.0000000.0188980.037796
0.0000000.0000000.0000000.0000000.004762

検算
1.000000 0.500000 0.333333 0.250000 0.200000
0.500000 0.333333 0.250000 0.200000 0.166667
0.333333 0.250000 0.200000 0.166667 0.142857
0.250000 0.200000 0.166667 0.142857 0.125000
0.200000 0.166667 0.142857 0.125000 0.111111
```

である。

### Hilbert行列の逆行列
これを元にLとUの逆行列を以下で計算する
```.inverse.c
  /*Lの逆行列*/
  printf("\nLの逆行列\n");
  for( i = 0;i < 5; i++){
    for( j = 0;j < 5; j++){
      if( i < j ){
        InverseL[i][j] = 0.0;
        printf("%f ", InverseL[i][j]);
      }else if( i == j ){
        InverseL[i][i] = 1.0/L[i][i];
        printf("%f ", InverseL[i][i]);
      }else {
        double tmp = 0.0;
        for(int k = 0; k < i; k++){
          tmp += L[i][k]*InverseL[k][j];
        }
        InverseL[i][j] = - tmp/L[i][i];
        printf("%f ", InverseL[i][j]);
      }
    }
    printf("\n");
  }

  /*L検算*/
  printf("\n検算\n");
  for(i=0;i<5;i++){
    for(j=0;j<5;j++){
      double tmp = 0.0;
     for(int k=0; k<5; k++){
        tmp += L[i][k]*InverseL[k][j];
     } 
     printf("%lf ", tmp);
    }
    printf("\n");
  }

  /*Uの逆行列*/
  printf("\nUの逆行列\n");
  for( i = 0; i < 5; i++ ){
    for(j = 0; j < 5; j++){
      InverseU[i][j] = InverseL[j][i];
      printf("%f ", InverseU[i][j]);
    }
    printf("\n");
  }

  /*U検算*/
  printf("\n検算\n");
  for(i=0;i<5;i++){
    for(j=0;j<5;j++){
      double tmp = 0.0;
     for(int k=0; k<5; k++){
        tmp += InverseU[i][k]*U[k][j];
     } 
     printf("%lf ", tmp);
    }
    printf("\n");
  }
```

実行結果は
```
Lの逆行列
1.000000 0.000000 0.000000 0.000000 0.000000
-1.732051 3.464102 0.000000 0.000000 0.000000
2.236068 -13.416408 13.416408 0.000000 0.000000
-2.645751 31.749016 -79.372539 52.915026 0.000000
3.000000 -60.000000 270.000000 -420.000000 210.000000

検算
1.000000 0.000000 0.000000 0.000000 0.000000
0.000000 1.000000 0.000000 0.000000 0.000000
0.000000 0.000000 1.000000 0.000000 0.000000
-0.000000 0.000000 0.000000 1.000000 0.000000
0.000000 0.000000 0.000000 0.000000 1.000000

Uの逆行列
1.000000 -1.732051 2.236068 -2.645751 3.000000
0.000000 3.464102 -13.416408 31.749016 -60.000000
0.000000 0.000000 13.416408 -79.372539 270.000000
0.000000 0.000000 0.000000 52.915026 -420.000000
0.000000 0.000000 0.000000 0.000000 210.000000

検算
1.000000 0.000000 0.000000 -0.000000 0.000000
0.000000 1.000000 0.000000 0.000000 0.000000
0.000000 0.000000 1.000000 0.000000 0.000000
0.000000 0.000000 0.000000 1.000000 0.000000
0.000000 0.000000 0.000000 0.000000 1.000000
```

$ U^{-1}L^{-1} $ を計算すれば良いので

```
  /*Hilebertの逆行列*/
  printf("\nHilbertの逆行列\n");
  for(i=0;i<5;i++){
    for(j=0;j<5;j++){
        InverseHierbert[i][j]= 0.0;
     for(int k=0; k<5; k++){
        InverseHierbert[i][j]+= InverseU[i][k]*InverseL [k][j];
     } 
     printf("%lf ", InverseHierbert[i][j]);
    }
    printf("\n");
  }

  /*Hilbertの検算*/
  printf("\nHilbertの検算\n");
  for(i=0;i<5;i++){
    for(j=0;j<5;j++){
      double tmp = 0.0;
     for(int k=0; k<5; k++){
        tmp += Hilbelt[i][k]*InverseHierbert[k][j];
     } 
     printf("%lf ", tmp);
    }
    printf("\n");
  }
```
結果は
```
Hilbertの逆行列
25.000000 -300.000000 1050.000000 -1400.000000 630.000000
-300.000000 4800.000000 -18900.000000 26880.000000 -12600.000000
1050.000000 -18900.000000 79380.000000 -117600.000000 56700.000000
-1400.000000 26880.000000 -117600.000000 179199.999999 -88200.000000
630.000000 -12600.000000 56700.000000 -88200.000000 44100.000000

Hilbertの検算
1.000000 -0.000000 -0.000000 0.000000 -0.000000
-0.000000 1.000000 -0.000000 0.000000 -0.000000
-0.000000 0.000000 1.000000 0.000000 0.000000
-0.000000 -0.000000 0.000000 1.000000 0.000000
-0.000000 0.000000 -0.000000 0.000000 1.000000
```
より逆行列が計算できたことが確認できた。
$ n = 10, 15 $の場合は長くなるためレポート末尾に載せた。

## (1)
上の準備の上所望のノルムを計算すると
```
  /*逆行列のノルム*/
  InversRow[0] = 0.0;
  for(i=0;i<N;i++){
    for(j=0;j<N;j++){
      InversRow[i]+= fabsl(InverseHierbert[i][j]);
    }
    printf("%d行の和 = %Lf\n",i, InversRow[i]);
  }
  InversMaxRow = InversRow[0];
  for(i=0;i<N;i++){
    if(InversRow[i] > InversMaxRow)
      InversMaxRow = InversRow[i];
  }

  /*ノルム*/
  Row[0] = 0.0;
  for(i=0;i<N;i++){
    for(j=0;j<N;j++){
      Row[i]+= fabsl(Hilbelt[i][j]);
    }
    printf("%d行の和 = %Lf\n",i, Row[i]);
  }
  MaxRow = Row[0];
  for(i=0;i<N;i++){
    if(Row[i] > MaxRow)
      MaxRow = Row[i];
  }
  printf("\n条件数= %Lf\n", MaxRow*InversMaxRow);
```
| $ n = 5 $ | $ n = 10 $ |$ n = 15 $|
|---|---|---|
|943656.000002|35350806896537.182865|18960736249266216480.000000|


となった。

## (2)
まず、解の要素が全て1となるような右辺項を求める。
つまり、行列と要素がすべて1の縦ベクトルのかけ算をすれば良い。
```
  Row[0] = 0.0;
  for(i=0;i<N;i++){
    for(j=0;j<N;j++){
      Row[i]+= Hilbelt[i][j];
    }
    printf("b[%d] = %Lf\n",i, Row[i]);
  }
```
各nに対する右辺項は

$ n = 5 $
```
b[0] = 2.283333
b[1] = 1.450000
b[2] = 1.092857
b[3] = 0.884524
b[4] = 0.745635
```

$ n = 10 $

```
b[0] = 2.928968
b[1] = 2.019877
b[2] = 1.603211
b[3] = 1.346800
b[4] = 1.168229
b[5] = 1.034896
b[6] = 0.930729
b[7] = 0.846695
b[8] = 0.777251
b[9] = 0.718771
```

$ n = 15 $
``` 
b[0] = 3.318229
b[1] = 2.380729
b[2] = 1.939553
b[3] = 1.661775
b[4] = 1.464406
b[5] = 1.314406
b[6] = 1.195359
b[7] = 1.097956
b[8] = 1.016434
b[9] = 0.946990
b[10] = 0.886990
b[11] = 0.834542
b[12] = 0.788246
b[13] = 0.747037
b[14] = 0.710091
```

となった。
これを踏まえた上でPivot選択付きGaussの消去法によって指定の方程式を解く。

```
```


## (3)

## (4)

## (5)

## 計算結果
